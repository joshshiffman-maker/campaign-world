<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ“Š Campaign World â€” Explore Your Projections</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323:wght@400&display=swap');

  :root {
    --gb-dark:    #0f380f;
    --gb-mid:     #306230;
    --gb-light:   #8bac0f;
    --gb-pale:    #9bbc0f;
    --bg:         #1a1a2e;
    --panel-bg:   #0d0d1a;
    --panel-border: #4a90d9;
    --text-main:  #e8f4e8;
    --text-dim:   #7a9a7a;
    --gold:       #ffd700;
    --blue:       #4a90d9;
    --teal:       #00bcd4;
    --green:      #4caf50;
    --red:        #f44336;
    --tile:       32;
    --map-w:      24;
    --map-h:      18;
  }

  * { margin:0; padding:0; box-sizing:border-box; image-rendering:pixelated; }

  body {
    background: var(--bg);
    font-family: 'Press Start 2P', monospace;
    overflow: hidden;
    width: 100vw; height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  /* â”€â”€â”€ TITLE SCREEN â”€â”€â”€ */
  #title-screen {
    position: fixed; inset:0;
    background: #0f0f1a;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 100;
    gap: 24px;
  }
  #title-screen h1 {
    font-family: 'Press Start 2P', monospace;
    font-size: clamp(14px,3vw,28px);
    color: var(--gold);
    text-shadow: 4px 4px 0 #7a5200, 0 0 30px rgba(255,215,0,0.5);
    text-align: center;
    line-height: 1.6;
    animation: titlePulse 2s ease-in-out infinite;
  }
  @keyframes titlePulse {
    0%,100% { text-shadow: 4px 4px 0 #7a5200, 0 0 20px rgba(255,215,0,0.4); }
    50%      { text-shadow: 4px 4px 0 #7a5200, 0 0 50px rgba(255,215,0,0.9); }
  }
  #title-screen .subtitle {
    font-size: 10px; color: var(--teal);
    animation: blink 1.2s step-end infinite;
  }
  @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0} }
  #title-screen .version { font-size: 8px; color: var(--text-dim); }
  #start-btn {
    background: var(--blue); border: 3px solid var(--text-main);
    color: #fff; font-family: 'Press Start 2P'; font-size: 11px;
    padding: 12px 28px; cursor: pointer;
    box-shadow: 4px 4px 0 #000;
    transition: transform 0.1s;
  }
  #start-btn:hover { transform: translate(-2px,-2px); box-shadow: 6px 6px 0 #000; }
  #start-btn:active { transform: translate(2px,2px); box-shadow: 2px 2px 0 #000; }

  /* â”€â”€â”€ GAME WRAPPER â”€â”€â”€ */
  #game-wrapper {
    position: relative;
    display: none;
    flex-direction: column;
    align-items: center;
  }

  /* â”€â”€â”€ STATUS BAR â”€â”€â”€ */
  #status-bar {
    width: 100%;
    background: #060610;
    border-bottom: 2px solid var(--blue);
    padding: 6px 16px;
    display: flex; align-items: center; justify-content: space-between;
    font-size: 8px; color: var(--text-dim);
  }
  #status-bar .title { color: var(--gold); font-size: 9px; }
  #controls-hint { color: var(--text-dim); font-size: 7px; }

  /* â”€â”€â”€ CANVAS â”€â”€â”€ */
  #game-canvas {
    display: block;
    border: 3px solid var(--blue);
    box-shadow: 0 0 40px rgba(74,144,217,0.3), inset 0 0 60px rgba(0,0,0,0.5);
    cursor: default;
  }

  /* â”€â”€â”€ INFO PANEL â”€â”€â”€ */
  #info-panel {
    position: fixed; inset:0;
    background: rgba(0,0,0,0.85);
    display: none; align-items: center; justify-content: center;
    z-index: 50;
    backdrop-filter: blur(4px);
  }
  #info-panel.open { display: flex; }
  #panel-box {
    background: var(--panel-bg);
    border: 4px solid var(--panel-border);
    box-shadow: 0 0 0 2px #000, 8px 8px 0 rgba(0,0,0,0.6), 0 0 60px rgba(74,144,217,0.3);
    width: min(680px, 95vw);
    max-height: 88vh;
    overflow-y: auto;
    padding: 0;
    display: flex; flex-direction: column;
    position: relative;
  }
  #panel-header {
    background: var(--panel-border);
    padding: 14px 20px;
    display: flex; justify-content: space-between; align-items: center;
  }
  #panel-title {
    font-size: 12px; color: #fff;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
  }
  #panel-close {
    background: var(--red); border: none; color: #fff;
    font-family: 'Press Start 2P'; font-size: 9px;
    padding: 6px 10px; cursor: pointer;
    box-shadow: 2px 2px 0 #000;
  }
  #panel-close:hover { background: #d32f2f; }
  #panel-body { padding: 20px; flex:1; }
  #panel-emoji { font-size: 40px; display: block; margin-bottom: 12px; }
  #panel-tagline {
    font-family: 'VT323', monospace; font-size: 22px;
    color: var(--gold); margin-bottom: 14px; line-height: 1.3;
  }
  #panel-desc {
    font-family: 'VT323', monospace; font-size: 17px;
    color: var(--text-main); line-height: 1.6;
    margin-bottom: 16px;
  }
  .panel-tags { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
  .tag {
    background: rgba(74,144,217,0.2);
    border: 2px solid var(--blue);
    color: var(--teal); font-size: 8px; padding: 4px 8px;
  }
  .panel-metrics {
    display: grid; grid-template-columns: 1fr 1fr;
    gap: 10px; margin-bottom: 18px;
  }
  .metric-card {
    background: rgba(255,255,255,0.04);
    border: 2px solid rgba(74,144,217,0.3);
    padding: 12px;
  }
  .metric-label { font-size: 7px; color: var(--text-dim); margin-bottom: 6px; }
  .metric-value { font-size: 14px; color: var(--gold); }
  .metric-delta { font-size: 8px; color: var(--green); margin-top: 4px; }
  #ask-btn {
    background: linear-gradient(135deg, #1a3a5c, #0d2040);
    border: 3px solid var(--teal);
    color: var(--teal); font-family: 'Press Start 2P'; font-size: 9px;
    padding: 12px 20px; cursor: pointer; width: 100%;
    box-shadow: 3px 3px 0 #000;
    transition: all 0.15s;
  }
  #ask-btn:hover {
    background: rgba(0,188,212,0.15);
    box-shadow: 5px 5px 0 #000; transform: translate(-1px,-1px);
  }

  /* â”€â”€â”€ CHAT â”€â”€â”€ */
  #chat-area {
    display: none; margin-top: 14px;
    border: 2px solid rgba(74,144,217,0.4);
    background: rgba(0,0,0,0.4);
  }
  #chat-area.open { display: block; }
  #chat-messages {
    height: 160px; overflow-y: auto;
    padding: 10px; display: flex; flex-direction: column; gap: 8px;
  }
  .chat-msg {
    font-family: 'VT323'; font-size: 16px; padding: 8px 10px;
    max-width: 85%; line-height: 1.4;
  }
  .chat-msg.user {
    background: rgba(74,144,217,0.2); color: var(--blue);
    align-self: flex-end; border: 1px solid var(--blue);
  }
  .chat-msg.ai {
    background: rgba(0,188,212,0.1); color: var(--teal);
    align-self: flex-start; border: 1px solid var(--teal);
  }
  #chat-input-row {
    display: flex; border-top: 1px solid rgba(74,144,217,0.3);
  }
  #chat-input {
    flex:1; background: transparent; border: none;
    color: var(--text-main); font-family: 'VT323'; font-size: 16px;
    padding: 8px 12px; outline: none;
  }
  #chat-send {
    background: var(--blue); border: none; color: #fff;
    font-family: 'Press Start 2P'; font-size: 8px;
    padding: 0 14px; cursor: pointer;
  }

  /* â”€â”€â”€ INTERACTION BUBBLE â”€â”€â”€ */
  #interact-hint {
    position: fixed; bottom: 24px; left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.9);
    border: 2px solid var(--gold);
    color: var(--gold); font-size: 8px;
    padding: 8px 16px;
    display: none;
    animation: hintBounce 0.8s ease-in-out infinite;
    z-index: 40;
  }
  @keyframes hintBounce {
    0%,100%{ transform: translateX(-50%) translateY(0); }
    50%{ transform: translateX(-50%) translateY(-4px); }
  }

  /* â”€â”€â”€ SCROLLBAR â”€â”€â”€ */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: #000; }
  ::-webkit-scrollbar-thumb { background: var(--blue); }
</style>
</head>
<body>

<!-- TITLE SCREEN -->
<div id="title-screen">
  <div style="font-size:56px;margin-bottom:8px;">ğŸ“Š</div>
  <h1>CAMPAIGN<br>WORLD</h1>
  <div class="subtitle">â–¶ PRESS START TO EXPLORE â—€</div>
  <button id="start-btn" onclick="startGame()">START GAME</button>
  <div class="version">v1.0 â€” Custom 30D Click â€¢ Marâ€“May 2026</div>
</div>

<!-- GAME -->
<div id="game-wrapper">
  <div id="status-bar">
    <span class="title">ğŸ“Š CAMPAIGN WORLD</span>
    <span id="controls-hint">ARROWS/WASD: MOVE &nbsp;|&nbsp; E / SPACE: INTERACT &nbsp;|&nbsp; ESC: CLOSE</span>
    <span id="pos-display">ğŸ—ºï¸ EXPLORING...</span>
  </div>
  <canvas id="game-canvas"></canvas>
</div>

<!-- INTERACTION HINT -->
<div id="interact-hint">â¬† PRESS E TO ENTER</div>

<!-- INFO PANEL -->
<div id="info-panel">
  <div id="panel-box">
    <div id="panel-header">
      <span id="panel-title">LOCATION</span>
      <button id="panel-close" onclick="closePanel()">âœ• CLOSE</button>
    </div>
    <div id="panel-body">
      <span id="panel-emoji"></span>
      <div id="panel-tagline"></div>
      <div id="panel-desc"></div>
      <div id="panel-tags" class="panel-tags"></div>
      <div id="panel-metrics" class="panel-metrics"></div>
      <button id="ask-btn" onclick="toggleChat()">ğŸ¤– ASK ABOUT THIS â†’</button>
      <div id="chat-area">
        <div id="chat-messages"></div>
        <div id="chat-input-row">
          <input id="chat-input" placeholder="Ask anything about this area..." />
          <button id="chat-send" onclick="sendChat()">SEND</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD DATA â€” edit this to add new buildings/regions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const WORLD_DATA = {
  name: "Campaign World",
  regions: ["Downtown Analytics", "Scenario District", "Metrics Plaza"],
  buildings: [
    {
      id: "hq",
      name: "BENCHMARK HQ",
      emoji: "ğŸ›ï¸",
      tagline: "Where it all began â€” Feb MTD",
      desc: "The central hub tracking current campaign performance. Every metric here represents real February month-to-date data â€” the baseline against which all projections are measured.",
      tags: ["Benchmark", "Feb MTD", "Baseline"],
      metrics: [
        { label: "ADVERTISER IMPRESSIONS", value: "748,201", delta: "Current baseline" },
        { label: "ACQUISITIONS", value: "783", delta: "20-day MTD" },
        { label: "CUSTOM CPA", value: "$82", delta: "Cost per acquisition" },
        { label: "DAILY RUN RATE", value: "$3,193", delta: "Avg spend/day" },
      ],
      context: "Benchmark HQ tracks February month-to-date performance: 316M network impressions, 0.24% SOV, 748,201 advertiser impressions, 44,193 referrals, 5.91% ER, $1.44 CPR, 783 acquisitions, $82 CPA, $63,857 total spend over 20 days, $3,193 daily run rate.",
      tileX: 11, tileY: 4, color: "#4a90d9",
    },
    {
      id: "s90",
      name: "$90 CPA TOWER",
      emoji: "ğŸ”µ",
      tagline: "Conservative Growth â€” Safe Scale",
      desc: "The $90 CPA scenario represents the most conservative bid strategy. Strong impression volume with proven efficiency. Ideal for proving incrementality before committing to higher spend.",
      tags: ["$90 CPA", "Conservative", "Safe Scale", "0.28% SOV"],
      metrics: [
        { label: "AVG IMPRESSIONS/MO", value: "1,167,105", delta: "+56% vs benchmark" },
        { label: "AVG ACQUISITIONS", value: "1,246", delta: "+59% lift" },
        { label: "AVG SPEND/MO", value: "~$112,119", delta: "+75% increase" },
        { label: "AVG DAILY RUN RATE", value: "~$3,655", delta: "+14% vs current" },
      ],
      months: [
        { m: "Mar '26", imp: "1,162,870", ref: "68,958", acq: "1,241", spend: "$111,712", drr: "$3,604" },
        { m: "Apr '26", imp: "1,100,008", ref: "65,230", acq: "1,174", spend: "$105,673", drr: "$3,522" },
        { m: "May '26", imp: "1,238,436", ref: "73,439", acq: "1,322", spend: "$118,972", drr: "$3,838" },
      ],
      context: "$90 CPA scenario projections: March '26 - 1,162,870 impressions, 68,958 referrals, 1,241 acquisitions, $111,712 spend, $3,604 DRR. April '26 - 1,100,008 impressions, 65,230 referrals, 1,174 acquisitions, $105,673 spend, $3,522 DRR. May '26 - 1,238,436 impressions, 73,439 referrals, 1,322 acquisitions, $118,972 spend, $3,838 DRR. SOV: 0.28%, ER: 5.93%.",
      tileX: 5, tileY: 8, color: "#2563eb",
    },
    {
      id: "s95",
      name: "$95 CPA PLAZA",
      emoji: "ğŸŸ¦",
      tagline: "Balanced Growth â€” Recommended",
      desc: "The $95 CPA scenario hits the sweet spot between scale and efficiency. This is the recommended starting point â€” strong acquisition lift with manageable spend increase. The optimal bid for most scenarios.",
      tags: ["$95 CPA", "Balanced", "Recommended â­", "0.29% SOV"],
      metrics: [
        { label: "AVG IMPRESSIONS/MO", value: "1,208,787", delta: "+62% vs benchmark" },
        { label: "AVG ACQUISITIONS", value: "1,309", delta: "+67% lift" },
        { label: "AVG SPEND/MO", value: "~$123,707", delta: "+94% increase" },
        { label: "AVG DAILY RUN RATE", value: "~$4,032", delta: "+26% vs current" },
      ],
      context: "$95 CPA scenario projections: March '26 - 1,204,401 impressions, 71,662 referrals, 1,304 acquisitions, $123,258 spend, $3,976 DRR. April '26 - 1,139,294 impressions, 67,788 referrals, 1,234 acquisitions, $116,595 spend, $3,887 DRR. May '26 - 1,282,666 impressions, 76,319 referrals, 1,389 acquisitions, $131,268 spend, $4,234 DRR. SOV: 0.29%, ER: 5.95%. This is the recommended scenario.",
      tileX: 17, tileY: 9, color: "#0891b2",
    },
    {
      id: "s100",
      name: "$100 CPA FORTRESS",
      emoji: "ğŸŸ©",
      tagline: "Aggressive Scale â€” Max Volume",
      desc: "The $100 CPA scenario unlocks maximum reach and acquisition volume. Best justified with LTV data or ahead of the VBB rollout. A 78% lift in acquisitions makes this a powerful option when efficiency metrics support it.",
      tags: ["$100 CPA", "Aggressive", "Max Volume", "0.30% SOV"],
      metrics: [
        { label: "AVG IMPRESSIONS/MO", value: "1,250,469", delta: "+67% vs benchmark" },
        { label: "AVG ACQUISITIONS", value: "1,395", delta: "+78% lift" },
        { label: "AVG SPEND/MO", value: "~$139,552", delta: "+119% increase" },
        { label: "AVG DAILY RUN RATE", value: "~$4,549", delta: "+42% vs current" },
      ],
      context: "$100 CPA scenario projections: March '26 - 1,245,932 impressions, 74,756 referrals, 1,390 acquisitions, $139,046 spend, $4,485 DRR. April '26 - 1,178,580 impressions, 70,715 referrals, 1,315 acquisitions, $131,529 spend, $4,384 DRR. May '26 - 1,326,896 impressions, 79,614 referrals, 1,481 acquisitions, $148,082 spend, $4,777 DRR. SOV: 0.30%, ER: 6.00%.",
      tileX: 12, tileY: 13, color: "#059669",
    },
    {
      id: "sov",
      name: "SOV OBSERVATORY",
      emoji: "ğŸ”­",
      tagline: "Share of Voice â€” The Signal Tower",
      desc: "Share of Voice determines how often your ad appears relative to total network impressions. From 0.24% benchmark to 0.30% at $100 CPA â€” each tick up means significantly more impressions as the network serves 400M+ impressions.",
      tags: ["SOV", "Impressions", "Network", "Scaling"],
      metrics: [
        { label: "BENCHMARK SOV", value: "0.24%", delta: "748K impressions" },
        { label: "$90 CPA SOV", value: "0.28%", delta: "~1.17M impressions" },
        { label: "$95 CPA SOV", value: "0.29%", delta: "~1.21M impressions" },
        { label: "$100 CPA SOV", value: "0.30%", delta: "~1.25M impressions" },
      ],
      context: "SOV (Share of Voice) analysis: At 0.24% SOV the campaign gets 748,201 impressions. At 0.28% SOV ($90 CPA) roughly 1.17M impressions. At 0.29% SOV ($95 CPA) roughly 1.21M impressions. At 0.30% SOV ($100 CPA) roughly 1.25M impressions. Network has 392-442M impressions per month.",
      tileX: 20, tileY: 4, color: "#8b5cf6",
    },
    {
      id: "vbb",
      name: "VBB LAB",
      emoji: "ğŸ§ª",
      tagline: "Value-Based Bidding â€” The Future",
      desc: "The next evolution of campaign optimization. Once the SDK is implemented, Value-Based Bidding will unlock predicted LTV models and audience capabilities â€” allowing the system to bid based on customer lifetime value, not just acquisition cost.",
      tags: ["VBB", "LTV", "SDK", "Future", "Audience"],
      metrics: [
        { label: "STATUS", value: "PENDING", delta: "SDK in progress" },
        { label: "UNLOCKS", value: "VBB + Audiences", delta: "Post-SDK" },
        { label: "STRATEGY", value: "LTV Models", delta: "Predicted value" },
        { label: "TIMELINE", value: "Medium-term", delta: "Next milestone" },
      ],
      context: "Value-Based Bidding (VBB) is the medium-term optimization strategy. It depends on implementing a new SDK that will unlock VBB and audience capabilities. Once live, campaigns can bid based on predicted customer lifetime value (LTV) rather than just CPA targets, significantly improving efficiency.",
      tileX: 4, tileY: 13, color: "#f59e0b",
    },
    {
      id: "ltv",
      name: "LTV DOJO",
      emoji: "âš”ï¸",
      tagline: "Lifetime Value â€” The Long Game",
      desc: "True campaign ROI lives here. Short-term: manual analysis for Day 40 and Day 90 milestone users. Medium-term: automated LTV models feeding the VBB system. The goal is to shift from CPA optimization to value-based growth.",
      tags: ["LTV", "Day 40", "Day 90", "Cohort", "Analytics"],
      metrics: [
        { label: "SHORT-TERM PLAN", value: "Manual", delta: "D40 + D90 analysis" },
        { label: "MILESTONE", value: "Day 40", delta: "First checkpoint" },
        { label: "MILESTONE", value: "Day 90", delta: "Retention signal" },
        { label: "GOAL", value: "VBB Ready", delta: "Connect to bidding" },
      ],
      context: "LTV strategy involves a two-pronged approach: short-term manual analysis of users reaching Day 40 and Day 90 milestones for creative experimentation, and medium-term implementation of Value-Based Bidding using predicted LTV models. The SDK implementation is the key dependency.",
      tileX: 8, tileY: 15, color: "#ef4444",
    },
    {
      id: "creative",
      name: "CREATIVE STUDIO",
      emoji: "ğŸ¨",
      tagline: "Ad Creative â€” The Conversion Engine",
      desc: "This is where engagement rates are born. Moving from 5.91% to 6.00% ER across scenarios shows that better targeting through higher CPA bids reaches more engaged audiences. Creative strategy and placement optimization live here.",
      tags: ["Creative", "ER", "CVR", "A/B Testing"],
      metrics: [
        { label: "BENCHMARK ER", value: "5.91%", delta: "Current baseline" },
        { label: "$90/$95 ER", value: "5.93â€“5.95%", delta: "Incremental gains" },
        { label: "$100 ER", value: "6.00%", delta: "Peak engagement" },
        { label: "CVR RANGE", value: "1.77â€“1.86%", delta: "Conversion rate" },
      ],
      context: "Creative performance data: Benchmark ER is 5.91%, CVR 1.77%. At $90 CPA: ER 5.93%, CVR 1.80%. At $95 CPA: ER 5.95%, CVR 1.82%. At $100 CPA: ER 6.00%, CVR 1.86%. CPR ranges from $1.44 (benchmark) to $1.86 ($100 CPA).",
      tileX: 20, tileY: 13, color: "#ec4899",
    },
  ],
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TILE MAP  (0=grass, 1=path, 2=water, 3=tree, 4=building, 5=road)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const W = 24, H = 18;
const RAW_MAP = [
  //  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
  [  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], // 0
  [  2, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 2], // 1
  [  2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 2], // 2
  [  2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2], // 3
  [  2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2], // 4
  [  2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2], // 5
  [  2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 2], // 6
  [  2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 2], // 7
  [  2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2], // 8
  [  2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 3, 0, 2], // 9
  [  2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2], // 10
  [  2, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 3, 2], // 11
  [  2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2], // 12
  [  2, 0, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 4, 1, 0, 0, 0, 1, 0, 0, 4, 0, 0, 2], // 13
  [  2, 0, 0, 0, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2], // 14
  [  2, 3, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2], // 15
  [  2, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 2], // 16
  [  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], // 17
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLORS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TILE_COLORS = {
  0: { base: "#2d5a27", detail: "#3a7033" },  // grass
  1: { base: "#a08040", detail: "#b89050" },  // path
  2: { base: "#1a3a5c", detail: "#1e4a70" },  // water
  3: { base: "#1a5c1a", detail: "#228b22" },  // tree
  4: { base: "#5c3d2e", detail: "#7a5040" },  // building base
  5: { base: "#808080", detail: "#909090" },  // road
};

// Building colors per ID
const BLDG_COLORS = {};
WORLD_DATA.buildings.forEach(b => { BLDG_COLORS[b.id] = b.color; });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let player = { x: 11.5, y: 8.5, dir: "down", frame: 0, moving: false };
let keys = {};
let nearBuilding = null;
let currentBuilding = null;
let animFrame = 0;
let lastTime = 0;
let walkTimer = 0;
const WALK_SPEED = 4.5; // tiles/sec
const TILE = 32;
let cameraX = 0, cameraY = 0;
let chatContext = "";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CANVAS SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById("game-canvas");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

function resizeCanvas() {
  const maxW = window.innerWidth - 40;
  const maxH = window.innerHeight - 80;
  const scale = Math.min(Math.floor(maxW / (W * TILE)), Math.floor(maxH / (H * TILE)));
  const s = Math.max(1, scale);
  canvas.width  = W * TILE * s;
  canvas.height = H * TILE * s;
  canvas.style.width  = canvas.width + "px";
  canvas.style.height = canvas.height + "px";
  canvas._scale = s;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW TILE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawTile(x, y, type) {
  const s = canvas._scale;
  const px = x * TILE * s, py = y * TILE * s;
  const sz = TILE * s;
  const c = TILE_COLORS[type] || TILE_COLORS[0];

  if (type === 0) { // grass
    ctx.fillStyle = c.base;
    ctx.fillRect(px, py, sz, sz);
    ctx.fillStyle = c.detail;
    if ((x + y) % 3 === 0) { ctx.fillRect(px+sz*0.2, py+sz*0.3, sz*0.1, sz*0.1); }
    if ((x * 3 + y) % 5 === 0) { ctx.fillRect(px+sz*0.6, py+sz*0.6, sz*0.08, sz*0.1); }
  } else if (type === 1) { // path
    ctx.fillStyle = c.base;
    ctx.fillRect(px, py, sz, sz);
    ctx.fillStyle = c.detail;
    ctx.fillRect(px+1, py+1, sz-2, sz-2);
    ctx.fillStyle = "rgba(0,0,0,0.15)";
    ctx.fillRect(px, py, sz, 1*s);
    ctx.fillRect(px, py, 1*s, sz);
  } else if (type === 2) { // water
    ctx.fillStyle = c.base;
    ctx.fillRect(px, py, sz, sz);
    // animated shimmer
    const shimmer = Math.sin(animFrame * 0.05 + x * 0.7 + y * 0.5) * 0.5 + 0.5;
    ctx.fillStyle = `rgba(30,100,180,${shimmer * 0.3})`;
    ctx.fillRect(px + sz*0.1, py + sz*0.3, sz*0.8, sz*0.1);
    ctx.fillStyle = `rgba(30,100,180,${shimmer * 0.2})`;
    ctx.fillRect(px + sz*0.2, py + sz*0.6, sz*0.5, sz*0.08);
  } else if (type === 3) { // tree
    ctx.fillStyle = "#1a4a1a";
    ctx.fillRect(px, py, sz, sz);
    ctx.fillStyle = "#228b22";
    ctx.fillRect(px+sz*0.2, py+sz*0.05, sz*0.6, sz*0.7);
    ctx.fillStyle = "#1a6b1a";
    ctx.fillRect(px+sz*0.35, py, sz*0.3, sz*0.35);
    ctx.fillStyle = "#4a3010";
    ctx.fillRect(px+sz*0.4, py+sz*0.65, sz*0.2, sz*0.35);
  } else if (type === 4) { // building placeholder (overridden by building draw)
    ctx.fillStyle = c.base;
    ctx.fillRect(px, py, sz, sz);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW BUILDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawBuilding(b) {
  const s = canvas._scale;
  const px = b.tileX * TILE * s, py = b.tileY * TILE * s;
  const sz = TILE * s;
  const color = b.color || "#4a90d9";
  const isNear = nearBuilding && nearBuilding.id === b.id;

  // Glow effect when near
  if (isNear) {
    const glow = Math.sin(animFrame * 0.12) * 0.5 + 0.5;
    ctx.shadowColor = color;
    ctx.shadowBlur = 12 * s * glow;
  }

  // Building body
  ctx.fillStyle = color;
  ctx.fillRect(px + sz*0.05, py + sz*0.1, sz*0.9, sz*0.85);

  // Darker facade
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.fillRect(px + sz*0.05, py + sz*0.1, sz*0.9, sz*0.2);

  // Windows
  const winColor = isNear ? "#ffffaa" : "#aaddff";
  ctx.fillStyle = winColor;
  [[0.15,0.35],[0.55,0.35],[0.15,0.6],[0.55,0.6]].forEach(([wx,wy]) => {
    ctx.fillRect(px + sz*wx, py + sz*wy, sz*0.25, sz*0.18);
  });

  // Door
  ctx.fillStyle = "#000";
  ctx.fillRect(px + sz*0.35, py + sz*0.7, sz*0.3, sz*0.25);

  // Roof accent
  ctx.fillStyle = "rgba(255,255,255,0.2)";
  ctx.fillRect(px + sz*0.05, py + sz*0.1, sz*0.9, sz*0.05);

  // Name label
  ctx.shadowBlur = 0;
  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(px - sz*0.1, py - sz*0.35, sz*1.2, sz*0.3);
  ctx.fillStyle = isNear ? "#ffd700" : "#ffffff";
  ctx.font = `bold ${Math.max(5, 6*s)}px 'Press Start 2P'`;
  ctx.textAlign = "center";
  const shortName = b.name.split(" ").slice(0,2).join(" ");
  ctx.fillText(shortName, px + sz*0.5, py - sz*0.1);
  ctx.textAlign = "left";

  // "!" indicator when near
  if (isNear) {
    const bounce = Math.sin(animFrame * 0.15) * 3 * s;
    ctx.fillStyle = "#ffd700";
    ctx.font = `bold ${10*s}px 'Press Start 2P'`;
    ctx.textAlign = "center";
    ctx.fillText("!", px + sz*0.5, py - sz*0.5 - bounce);
    ctx.textAlign = "left";
    ctx.shadowBlur = 0;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW PLAYER (simple pixel sprite)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawPlayer() {
  const s = canvas._scale;
  const px = player.x * TILE * s, py = player.y * TILE * s;
  const sz = TILE * s;
  const walkBob = player.moving ? Math.sin(walkTimer * 15) * 2 * s : 0;

  // Shadow
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.ellipse(px + sz*0.5, py + sz*0.9, sz*0.25, sz*0.08, 0, 0, Math.PI*2);
  ctx.fill();

  // Body
  ctx.fillStyle = "#3a7bd5";
  ctx.fillRect(px + sz*0.25, py + sz*0.45 + walkBob, sz*0.5, sz*0.4);

  // Head
  ctx.fillStyle = "#f5cba7";
  ctx.fillRect(px + sz*0.3, py + sz*0.15 + walkBob, sz*0.4, sz*0.32);

  // Hair
  ctx.fillStyle = "#3d1a0a";
  ctx.fillRect(px + sz*0.28, py + sz*0.12 + walkBob, sz*0.44, sz*0.14);

  // Eyes (direction-based)
  ctx.fillStyle = "#1a1a2e";
  if (player.dir === "down") {
    ctx.fillRect(px + sz*0.36, py + sz*0.27 + walkBob, sz*0.08, sz*0.08);
    ctx.fillRect(px + sz*0.56, py + sz*0.27 + walkBob, sz*0.08, sz*0.08);
  } else if (player.dir === "up") {
    // back of head, no eyes
    ctx.fillStyle = "#3d1a0a";
    ctx.fillRect(px + sz*0.28, py + sz*0.12 + walkBob, sz*0.44, sz*0.24);
  } else {
    ctx.fillRect(px + (player.dir==="right" ? sz*0.54 : sz*0.38), py + sz*0.27 + walkBob, sz*0.08, sz*0.08);
  }

  // Legs (animated)
  ctx.fillStyle = "#2d4a8a";
  const legPhase = Math.sin(walkTimer * 15);
  if (player.moving) {
    ctx.fillRect(px + sz*0.28, py + sz*0.82 + walkBob + legPhase * 2 * s, sz*0.18, sz*0.15);
    ctx.fillRect(px + sz*0.54, py + sz*0.82 + walkBob - legPhase * 2 * s, sz*0.18, sz*0.15);
  } else {
    ctx.fillRect(px + sz*0.28, py + sz*0.82 + walkBob, sz*0.18, sz*0.15);
    ctx.fillRect(px + sz*0.54, py + sz*0.82 + walkBob, sz*0.18, sz*0.15);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLISION CHECK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function canMoveTo(tx, ty) {
  const gx = Math.floor(tx), gy = Math.floor(ty);
  if (gx < 0 || gy < 0 || gx >= W || gy >= H) return false;
  const t = RAW_MAP[gy]?.[gx];
  if (t === 2 || t === 3) return false;
  // Don't walk into building tiles
  for (const b of WORLD_DATA.buildings) {
    if (gx === b.tileX && gy === b.tileY) return false;
  }
  return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHECK PROXIMITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkNearBuilding() {
  nearBuilding = null;
  for (const b of WORLD_DATA.buildings) {
    const dx = player.x - b.tileX, dy = player.y - b.tileY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 1.8) { nearBuilding = b; break; }
  }
  document.getElementById("interact-hint").style.display = nearBuilding ? "block" : "none";
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPEN PANEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function openPanel(b) {
  currentBuilding = b;
  chatContext = b.context || b.desc;
  document.getElementById("panel-title").textContent = b.name;
  document.getElementById("panel-emoji").textContent = b.emoji;
  document.getElementById("panel-tagline").textContent = b.tagline;
  document.getElementById("panel-desc").textContent = b.desc;

  // Tags
  const tagsEl = document.getElementById("panel-tags");
  tagsEl.innerHTML = b.tags.map(t => `<span class="tag">${t}</span>`).join("");

  // Metrics
  const metricsEl = document.getElementById("panel-metrics");
  metricsEl.innerHTML = (b.metrics || []).map(m => `
    <div class="metric-card">
      <div class="metric-label">${m.label}</div>
      <div class="metric-value">${m.value}</div>
      <div class="metric-delta">â–² ${m.delta}</div>
    </div>
  `).join("");

  // Reset chat
  document.getElementById("chat-area").classList.remove("open");
  document.getElementById("chat-messages").innerHTML = "";

  document.getElementById("info-panel").classList.add("open");
  document.getElementById("interact-hint").style.display = "none";
}

function closePanel() {
  document.getElementById("info-panel").classList.remove("open");
  currentBuilding = null;
}

function toggleChat() {
  const area = document.getElementById("chat-area");
  area.classList.toggle("open");
  if (area.classList.contains("open") && document.getElementById("chat-messages").children.length === 0) {
    addChatMsg("ai", `Welcome to ${currentBuilding.name}! I know everything about this location. Ask me about the metrics, strategy, or projections here.`);
  }
  document.getElementById("chat-input").focus();
}

function addChatMsg(role, text) {
  const msgs = document.getElementById("chat-messages");
  const div = document.createElement("div");
  div.className = `chat-msg ${role}`;
  div.textContent = text;
  msgs.appendChild(div);
  msgs.scrollTop = msgs.scrollHeight;
}

async function sendChat() {
  const input = document.getElementById("chat-input");
  const q = input.value.trim();
  if (!q) return;
  addChatMsg("user", q);
  input.value = "";

  // Call Claude API
  addChatMsg("ai", "â–Œ thinking...");
  try {
    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        model: "claude-sonnet-4-20250514",
        max_tokens: 1000,
        system: `You are an AI guide inside a retro pixel game called "Campaign World." You are stationed at: ${currentBuilding?.name}. 

Context about this location: ${chatContext}

Respond in a fun, slightly gamified tone but with accurate data. Keep responses concise (2-4 sentences). You can use emojis. You're helping a Customer Success Manager understand their campaign projection scenarios for a Rokt advertising campaign.`,
        messages: [{ role: "user", content: q }]
      })
    });
    const data = await response.json();
    const msgs = document.getElementById("chat-messages");
    msgs.lastChild.remove();
    const text = data.content?.[0]?.text || "Hmm, signal lost. Try again!";
    addChatMsg("ai", text);
  } catch(e) {
    const msgs = document.getElementById("chat-messages");
    msgs.lastChild.remove();
    addChatMsg("ai", `ğŸ“¡ Signal lost! (API not connected yet) â€” But I can tell you: ${chatContext.split('.')[0]}.`);
  }
}

document.getElementById("chat-input").addEventListener("keydown", e => {
  if (e.key === "Enter") sendChat();
  e.stopPropagation();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function gameLoop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  animFrame++;

  const panelOpen = document.getElementById("info-panel").classList.contains("open");

  if (!panelOpen) {
    // Movement
    let dx = 0, dy = 0;
    if (keys["ArrowLeft"]  || keys["a"] || keys["A"]) dx -= 1;
    if (keys["ArrowRight"] || keys["d"] || keys["D"]) dx += 1;
    if (keys["ArrowUp"]    || keys["w"] || keys["W"]) dy -= 1;
    if (keys["ArrowDown"]  || keys["s"] || keys["S"]) dy += 1;

    if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }

    player.moving = (dx !== 0 || dy !== 0);
    if (player.moving) {
      walkTimer += dt;
      const spd = WALK_SPEED * dt;
      if (dx < 0) player.dir = "left";
      else if (dx > 0) player.dir = "right";
      else if (dy < 0) player.dir = "up";
      else if (dy > 0) player.dir = "down";

      const nx = player.x + dx * spd;
      const ny = player.y + dy * spd;
      if (canMoveTo(nx + 0.3, player.y + 0.5) && canMoveTo(nx + 0.7, player.y + 0.5)) player.x = nx;
      if (canMoveTo(player.x + 0.3, ny + 0.5) && canMoveTo(player.x + 0.7, ny + 0.5)) player.y = ny;
    }

    checkNearBuilding();
    document.getElementById("pos-display").textContent =
      `ğŸ“ ${Math.floor(player.x)},${Math.floor(player.y)}`;
  }

  // Draw
  const s = canvas._scale;
  ctx.fillStyle = "#1a1a2e";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw tiles
  for (let ty = 0; ty < H; ty++) {
    for (let tx = 0; tx < W; tx++) {
      drawTile(tx, ty, RAW_MAP[ty][tx]);
    }
  }

  // Draw buildings
  for (const b of WORLD_DATA.buildings) {
    drawBuilding(b);
  }

  // Draw player
  drawPlayer();

  requestAnimationFrame(gameLoop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener("keydown", e => {
  keys[e.key] = true;
  if (e.key === "Escape") closePanel();
  if ((e.key === "e" || e.key === "E" || e.key === " ") && nearBuilding) {
    openPanel(nearBuilding);
  }
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) {
    e.preventDefault();
  }
});
document.addEventListener("keyup", e => { keys[e.key] = false; });

// Touch/click on canvas to move toward click (bonus)
canvas.addEventListener("click", e => {
  const rect = canvas.getBoundingClientRect();
  const s = canvas._scale;
  const cx = (e.clientX - rect.left) / s / TILE;
  const cy = (e.clientY - rect.top) / s / TILE;
  // Check if clicking near a building
  for (const b of WORLD_DATA.buildings) {
    const dx = cx - b.tileX, dy = cy - b.tileY;
    if (Math.sqrt(dx*dx+dy*dy) < 1.5) { openPanel(b); return; }
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// START
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startGame() {
  document.getElementById("title-screen").style.display = "none";
  document.getElementById("game-wrapper").style.display = "flex";
  resizeCanvas();
  lastTime = performance.now();
  requestAnimationFrame(gameLoop);
}

window.addEventListener("resize", () => { if (document.getElementById("game-wrapper").style.display !== "none") resizeCanvas(); });
</script>
</body>
</html>
